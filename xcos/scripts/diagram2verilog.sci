function[ok] = diagram2verilog(diagram, target)
//generates hierachical verilog for an xcos diagram
//diagram = adjusted top level xcos diagram e.g adjust_diagram(preprocess_diagram(scs_m))
//target = path to superblock within top_diagram to be processed e.g [] for top

  ok = %f;
  fname = 'diagram2verilog';  

  if strcmp(typeof(diagram), 'diagram'),
    msg = msprintf('%s passed instead of diagram', typeof(diagram));
    ratel_log(msg+'\n', [fname, 'error']);
    return;
  end
  
  //TODO check target type

  dtitle = diagram.props.title;

  //locate target diagram within top level diagram based on target index
  ratel_log('locating target diagram \n', [fname]);
  for index = 1:length(target),
    offset = target(index);
    if offset > length(diagram.objs),
      msg = msprintf('block with offset %d does not exist in %s', offset, dtitle);
      ratel_log(msg+'\n', [fname, 'error']);
      return;
    end
    //check that it is a diagram
    obj = diagram.objs(offset);
    if strcmp(typeof(obj), 'diagram'),
      msg = msprintf('block with offset %d in %s not a ''diagram'' as required', offset, dtitle);
      ratel_log(msg+'\n', [fname, 'error']);
      return;
    end
    diagram = obj.model.rpar;
  end
 
  //create directory based on diagram name
  //we create a special directory as we may place other things here in future
  ratel_log(msprintf('creating %s', dtitle)+'\n', [fname]);
  ko = mkdir(dtitle);
  if ~ko,
    msg = msprintf('error creating directory %s while in %s', dtitle, pwd());
    ratel_log(msg+'\n',[fname, 'error']);
    return;
  end 

  //go into directory we just created 
  ratel_log(msprintf('changing directory to %s', dtitle)+'\n', [fname]);
  ko = chdir(dtitle);
  if ~ko,
    msg = msprintf('error changing current directory to %s from %s', dtitle, pwd());
    ratel_log(msg+'\n', [fname, 'error']);
    return;
  end

  //create or clear top file for writing
  ratel_log(msprintf('creating top.v for %s', dtitle)+'\n', [fname]);
  [fd, err] = mopen('top.v', 'w');
  //TODO error checking

  //verilog intro
  ratel_log('generating verilog module definition\n', [fname]);
  [ko] = verilog_intro(fd, diagram, []);
  if ~ko then
    ratel_log('error generating verilog module definition\n', [fname, 'error']);
    return;
  end //if

  //create links
  ratel_log('generating links\n', [fname]);
  [ko] = links2verilog(fd, diagram, []);
  if ~ko then
    ratel_log('error translating links\n', [fname, 'error']);
    return;
  end //if

  //create blocks
  //[ok] = blocks2verilog(fd, blocks, links); 
  //if ~ok ten
  //  ratel_log('error translating blocks\n', [fname, 'error']);
  //  return;
  //end //if

  //verilog epilogue
  [ko] = verilog_epilogue(fd, dtitle);
  if ~ko then
    ratel_log(msprintf('error writing epilogue for %s', dtitle) + '\n', [fname, 'error']);
    return;
  end //if

  //move back up in directory structure
  chdir('../');

  //close file
  mclose(fd);

  ok = %t;
endfunction //diagram2verilog

function[ok] = verilog_intro(fd, diagram, offset)
//generate the start of a verilog file including ports
//fd = target file to write intro in
//diagram = adjusted diagram to generate intro for e.g. adjust_diagram(scs_m)
//offset = list index of target superblock within diagram

  ok = %f; 
  fname = 'verilog_intro';

  dtitle = diagram.props.title; 

  mfprintf(fd, '//Generated by ratel version %s\n', ratel_version());
  mfprintf(fd, 'module %s\n', dtitle); 

  //we will use inports and outports to connect our logic to the outside world
  //for simulation and connection to busses etc

  mfprintf(fd, '\t(\n'); //beginning of ports

  mfprintf(fd, '// inports\n'); 
  //find all inports in our diagram (including in all superblocks)
  [inports, inports_indices, ko] = find_blocks_of_type('inport', diagram, %inf);
  if ~ko,
    ratel_log(msprintf('error finding inports in %s', dtitle)+'\n', [fname, 'error']);
    return;
  end
  ports_nbits = list(); ports_directions = list();
  for idx = 1:length(inports),
    port = inports(idx);
    [nbits, ko] = ratel_getattr(port, 'nbits_out');
    if ~ko | nbits == [],
      msg = msprintf('error getting ''nbits_out'' for port %s', port.graphics.exprs(1));
      ratel_log(msg+'\n', [fname, 'error']);
      return;
    end //if
    ports_nbits($+1) = nbits;
    ports_directions($+1) = 'input';
  end //for
  
  [ko] = ports2verilog(fd, ports_directions, ports_nbits, inports);
  if ~ko,
    ratel_log(msprintf('error generating inport ports for %s', dtitle)+'\n', [fname, 'error']);
    return;
  end

  mfprintf(fd, '\n// outports\n'); 
  //find all outports in our diagram (including in all superblocks)
  [outports, outport_indices, ko] = find_blocks_of_type('outport', diagram, %inf);
  if ~ko,
    ratel_log(msprintf('error while finding outports in %s', dtitle)+'\n', [fname, 'error']);
    return;
  end
  
  ports_nbits = list(); ports_directions = list();
  for idx = 1:length(outports),
    port = outports(idx);
    [nbits, ko] = ratel_getattr(port, 'nbits_in');
    if ~ko | nbits == [],
      msg = msprintf('error getting ''nbits_in'' for port %s', port.graphics.exprs(1));
      ratel_log(msg+'\n', [fname, 'error']);
      return;
    end //if
    ports_nbits($+1) = nbits;
    ports_directions($+1) = 'output';
  end //for

  [ko] = ports2verilog(fd, ports_directions, ports_nbits, outports);
  if ~ko,
    ratel_log(msprintf('error generating outport ports for %s', dtitle)+'\n', [fname, 'error']);
    return;
  end

  mfprintf(fd, '\n// standard ports\n'); 
  //find all inouts in top level of our diagram
  [inouts, inout_indices, ko] = find_blocks_of_type('inout', diagram, 0);
  if ~ko,
    ratel_log(msprintf('error while finding inouts in %s', dtitle)+'\n', [fname, 'error']);
    return;
  end

  ports_nbits = list(); ports_directions = list();
  for idx = 1:length(inouts),
    port = inouts(idx);
    [nbits, ko] = ratel_getattr(port, 'nbits_out');
    if ~ko | nbits == [],
      msg = msprintf('error getting ''nbits_out'' for port %s', port.graphics.exprs(1));
      ratel_log(msg+'\n', [fname, 'error']);
      return;
    end //if
    ports_nbits($+1) = nbits;
    ports_directions($+1) = port.opar(1).settings.type;
  end //for

  [ko] = ports2verilog(fd, ports_directions, ports_nbits, inouts);
  if ~ko,
    ratel_log(msprintf('error generating inout ports for %s', dtitle)+'\n', [fname, 'error']);
    return;
  end
  
  mfprintf(fd, '\n\t);\n'); //end of ports

  ok = %t;
endfunction //verilog_intro

function[ok] = ports2verilog(fd, ports_directions, ports_nbits, ports)
//convert ports of different types to verilog
//ports_directions are 'input' or 'output' for each port
//ports_n_bits_in are the bit width for each port
//ports are the port objects

  ok = %f;
  fname = 'ports2verilog';
  
  for idx = 1:length(ports),
    port_direction = ports_directions(idx);
    port_nbits = ports_nbits(idx);
    port = ports(idx);
    port_name = port.graphics.exprs(1);

    mfprintf(fd, '\t%s ', port_direction);
    if port_nbits > 1,
      mfprintf(fd, '[%d-1:0] ', port_nbits);
    end //if
    mfprintf(fd,' %s', port_name);
    if idx ~= length(ports), mfprintf(fd, ',\n'); end //if

  end //for
  ok = %t;
endfunction //ports2verilog

function[ok] = verilog_epilogue(fd, module_name)
  ok = %f;
  mfprintf(fd, 'endmodule //%s\n', module_name);
  ok = %t;
endfunction //verilog_epilogue 

function[ok] = blocks2verilog(fd, blocks, links)
  //TODOs
  ok = %t;
endfunction //blocks2verilog

function[ok] = links2verilog(fd, diagram, offset)
//convert xcos links to verilog wires
  ok = %f;
  fname = 'links2verilog';

  for index = 1:length(diagram.objs),
    obj = diagram.objs(index);
    if typeof(obj) == 'Link' then
      lnk = obj;
      
      from_index = lnk.from(1);
      from_port = lnk.from(2);
      from_type = lnk.from(3); 

      to_index = lnk.to(1);
      to_port = lnk.to(2);
      to_type = lnk.to(3); 

      //we use the block with the output port as the name
      if from_type == 0 then
        source_index = from_index;
        source_port = from_port;
      else
        source_index = to_index;
        source_port = to_port;
      end //if

      if source_index > length(diagram.objs) then
        msg = msprintf('source index (%d) for link (%d) exceeds number of blocks (%d)', source_index, link_index, length(objects));
        ratel_log(msg+'\n', [fname, 'error']);
        return;
      end

      source_block = diagram.objs(source_index);
      //TODO not enough to check for valid ratel block
      if strcmp(typeof(source_block), 'Block') ~= 0,
        ratel_log('not a valid ratel block\n', [fname, 'error']);
      end
      graphics = source_block.graphics;
      label = graphics.exprs(1);

      //we use the port index to uniquely identify the port
      //TODO use the port name as well
      link_name = msprintf('%s%d', label, source_port);

      //TODO width calculation

      mfprintf(fd, '\twire %s;\n', link_name);
    end //if     
  end //for
  ok = %t;
endfunction //links2verilog
