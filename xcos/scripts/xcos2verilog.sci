//function converting an xcos model using badger library blocks to verilog
function [result] = xcos2verilog(modelname, filename)
  result = -1;

  //TODO back up current file if exists

  //create or clear file for writing
  [fd, err] = mopen(filename, 'w');

  //TODO error checking
  
  //open model (handle in scs_m after load)
  importXcosDiagram(modelname);
  //get objects 
  objects = scs_m.objs;

  //TODO some sort of model check

  //sort into ports, links and blocks
  [result, ports, links, blocks] = sortblocks(objects);

  //verilog intro
  //TODO MS uses '\'
  name_tokens = tokens(modelname, ['/','.']);
  module_name = name_tokens($-1);
  //TODO what if filename ends with e.g .zcos.backup, need to strip more intelligently
  [result] = verilog_intro(fd, module_name, ports);

  //create ports
  [result] = ports2verilog(fd, ports);
  mfprintf(fd, '\n');

  //create links

  //create blocks

  //verilog epilogue
  [result] = verilog_epilogue(fd, module_name);

  //close file
  mclose(fd);

  result = 0;
endfunction //xcos2verilog

function[result] = verilog_epilogue(fd, module_name)
  result = -1;
  mfprintf(fd, 'endmodule //%s\n', module_name);
  result = 0;
endfunction //verilog_epilogue 

//function[result] = links2verilog(links, fd)

//endfunction //links2verilog

//function[result] = blocks2verilog(blocks, fd)

//endfunction //blocks2verilog

function[result] = ports2verilog(fd, ports)
  for port_index = 1:length(ports),
    port = ports(port_index);
    if (valid_port(port) == %T) then
      block_type = port.gui;
      if (strcmp(block_type, "inport") == 0) then 
        mfprintf(fd, '\tinput');
      elseif (strcmp(block_type, "outport") == 0) then 
        mfprintf(fd, '\toutput');        
      else
        mprintf('Unknown port of type %s found', block_type); 
      end //if

      //all ports are wires
      mfprintf(fd, ' wire');
      
      //find port size
      if (strcmp(block_type, "inport") == 0) then 
        model = port.model;
        settings = model.opar(4);
        n_bits = settings.n_bits;
        mfprintf(fd, ' [%d-1:0]', n_bits);
      end //if
      
      //find port label
      graphics = port.graphics;
      label = graphics.exprs(1);
      mfprintf(fd, ' %s;\n', label);

    end //if  
  end //for
endfunction //ports2verilog

//generate the start of a verilog file
function[result] = verilog_intro(fd, module_name, ports)
  result = -1; 

  mfprintf(fd, '//Generated by badger\n');
  mfprintf(fd, 'module %s(', module_name); 
  for port_index = 1:length(ports),
    port = ports(port_index);
    if (valid_port(port) == %T) then
      graphics = port.graphics;
      port_name = graphics.exprs(1);
      if port_index ~= 1 mfprintf(fd, ', '); end //if
      mfprintf(fd, '%s', port_name);
    end
  end //for	
  mfprintf(fd, ');\n');  

  result = 0;
endfunction //verilog_intro

function[result] = valid_port(port)
  result = %F;
  if length(port) ~= 5 then
    mprintf('Non-object slipped through');
    return;
  end //if
  block_type = port.gui;
  if ((strcmp(block_type, "inport") ~= 0) & (strcmp(block_type, "outport") ~= 0)) then
    mprintf('Non-port object slipped through'); 
    return;       
  end //if
  result = %T;
endfunction  

//sort model contents into ports, links and blocks
//as each is treated differently
function[result, ports, blocks, links] = sortblocks(objects)
  result = -1;
  ports = list();
  blocks = list();
  links = list();

  for obj_index = 1:length(objects),
    obj = objects(obj_index);
    //TODO is there a better way than checking length?
    
    //block
    if length(obj) == 5 then
      block_type = obj.gui;
      if ((strcmp(block_type, "inport") == 0) | (strcmp(block_type, "outport") == 0)) then
        ports($+1) = obj;
      else
        blocks($+1) = obj;
      end //if
    //link
    elseif length(obj) == 8 then
      //check that actually a link (TODO exception checking?)
      if strcmp(obj.id, 'drawlink') ~= 0 then
        mprintf('Correct length for link, wrong id %s', obj.id);
      else
        links($+1) = obj;
      end //if
    end //if
  end //for
  result = 0;
endfunction //sortblocks
